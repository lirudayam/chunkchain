<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <title>Chunkchain - Blockchain Try Out</title>
  <style>
    body { background-color: #333; font-size: 1.5em; padding: 0em 0.25em; }
    pre { color: #fff; white-space: pre-wrap; word-wrap: break-word; text-shadow: 0 0 10px #ccc; }
    #input { border-bottom: 1px solid #ccc; background-color: #383838; padding: 0.25em; outline: 0; }
    #input::before { content: "> "; }
  </style>
  <script>
    function log(message) {
      document.getElementById("log").textContent += message + "\n";
    }
  </script>
  <script src="https://chr15m.github.io/bugout/bugout.min.js" type="application/javascript"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/crypto-js.min.js"></script>
  <script src="https://momentjs.com/downloads/moment.js"></script>
  
</head>
<body>
  <pre id="log"></pre>
  <pre id="input" contenteditable="true"></pre>
</body>
<script>
    // Our interfaces for chats
    // using short codes to decrease network traffic and RAM consumption
    const oChatInterface = {
        s: "", // s - sender
        r: "", // r - recipient
        m: "", // m - message
        c: 0,  // c - coins
        t: 0,  // t - unix timestamp
        h: ""  // h - hash
    };

    const oBlockInterface = {
        h: "",  // h - hash
        p: "",  // p - previous block
        m: "",  // m - merkle root
        t: 0,   // t - time
        n: 0,   // n - nonce
        no: 0,  // no - number of transactions
        s: 0,   // s - size
        b: 0,   // b - block_index
        r: "",  // r - miner
        l: []   // l - list of transactions
    };

    // Enums for types of messages
    const oMsgKeys = {
        "A": "Outgoing message into unconfirmed transactions",
        "B": "New block found",
        "C": "Copy of blockchain",
        "N": "Announce nickname",
        "S": "Shared nickname dictionary"
    }
    const aKeys = Object.keys(oMsgKeys);

    let aBlockchain = [];
    let bMining = true;

    let oNickNames = {};

    var oBlock = Object.assign({}, oBlockInterface);
    let oMiningIntervalCaller = null;

    // Public-Private Key Simulation functions
    // Herefore we simulate that the Bugout Address is the public key
    // Hence we pretend some kind of reverse engineering from the public key

    function _rot13(sStr) { 
        var re = new RegExp("[a-z]", "i");
        var min = 'A'.charCodeAt(0);
        var max = 'Z'.charCodeAt(0);
        var factor = 13;
        var result = "";
        sStr = sStr.toUpperCase();
        
        for (var i=0; i<sStr.length; i++) {
            result += (re.test(sStr[i]) ?
            String.fromCharCode((sStr.charCodeAt(i) - min + factor) % (max-min+1) + min) : sStr[i]);
        }
        
        return result;
    }

    function _reverse(sStr){
        return sStr.split("").reverse().join("");
    }

    function getPrivateKey(sBugoutAddress) {
        return _reverse(_rot13(sBugoutAddress)).toLowerCase();
    }

    
    // Functions to encrypt our messages and to decrypt them
    function createTxHash(oChat, sPrivateKey) {
        oChat.t = moment().valueOf();
        var sComboundString = oChat.s + oChat.r + oChat.m + oChat.c + oChat.t;
        var sHashString = CryptoJS.enc.Hex.stringify(CryptoJS.SHA1(sComboundString.toString()));

        // sign the hash with the private key
        oChat.h = CryptoJS.AES.encrypt(sHashString, sPrivateKey).toString();

        return oChat;
    }

    function verifyTx(oChat) {
        var sComboundString = oChat.s + oChat.r + oChat.m + oChat.c + oChat.t;

        // simulate an asymmetric encyrption
        var sPrivatePersonKey = getPrivateKey(oChat.s);

        var sEncryptCombound = CryptoJS.enc.Hex.stringify(CryptoJS.SHA1(sComboundString.toString()));
        return CryptoJS.AES.decrypt(oChat.h, sPrivatePersonKey).toString(CryptoJS.enc.Utf8) === sEncryptCombound && oChat.t < moment().valueOf();
    }

    // Functions to create a block
    function startNewBlock() {
        oBlock = null;
        oBlock = Object.assign({}, oBlockInterface);
        oBlock.l = [];
    }

    function verifyBlock(oBlock) {
        var sComboundString = oBlock.l.map((tx) => tx.h).join("");

        // replace this soon with the real previous block
        sComboundString += oBlock.p;
        sComboundString += oBlock.t;
        sComboundString += oBlock.n;

        return oBlock.h === CryptoJS.SHA1(sComboundString).toString();
    }

    function calculateBlockHash(oBlock, nonce) {
        var sComboundString = oBlock.l.map((tx) => tx.h).join("");

        // replace this soon with the real previous block
        sComboundString += oBlock.p;
        sComboundString += oBlock.t;
        sComboundString += nonce;
        return CryptoJS.SHA1(sComboundString).toString();
    }

    function proofOfWorkMining(difficulty){
        var nonce = 0;
        var hash = "";

        if (oMiningIntervalCaller !== null) {
            clearInterval(oMiningIntervalCaller);
        }

        const miningFn = () => {
            if (bMining && oBlock.l.length > 3 && hash.substr(0, difficulty) !== Array(difficulty + 1).join("0")){
                oBlock.t = moment().valueOf();
                nonce++;
                hash = calculateBlockHash(oBlock, nonce);
                
                if (hash.substr(0, difficulty) === Array(difficulty + 1).join("0")) {
                    log("Nonce found: " + nonce); 

                    oBlock.h = hash;
                    oBlock.n = nonce;

                    b.send("B" + JSON.stringify(oBlock));
                    //aBlockchain.push(oBlock);
                    startNewBlock();
                    clearInterval(oMiningIntervalCaller);
                    return nonce;  
                }
            }  
        }    
        oMiningIntervalCaller = setInterval(miningFn, 50);    
    }

    // supporting functions
    function getNickname(sAddress) {
        if (oNickNames.hasOwnProperty(sAddress)) {
            return oNickNames[sAddress]
        };
        return sAddress;
    }

    // Get connected with our peers via torrent server
    var b = Bugout("chunkchain");

    // Register critical information
    const publicAddress = b.address();
    const privateKey = getPrivateKey(b.address());

    const sUserNickName = prompt("Please choose a nickname", "");



  log("Hello world!");

    
  log(b.address());

    // Register personal nickname across the network
    b.send("N" + JSON.stringify({
        k: publicAddress,
        n: sUserNickName
    }));
    oNickNames[publicAddress] = sUserNickName; 

    log(privateKey + " [ private key ]");

    b.on("seen", function(address) { 
        log(getNickname(address) + " [ seen ]"); 

        // send the nickname dicitonary as well
        b.send("S" + JSON.stringify(oNickNames));

        if (aBlockchain.length > 0) {
            // whenever a new participant joins the entire blockchain will be send
            b.send("C" + JSON.stringify(aBlockchain));
        }
    });

    b.on("left", function(address) { 
        log(getNickname(address) + " [ left ]"); 

        delete oNickNames[address];
    });
  log(b.address() + " [ me ]");
  
  b.on("message", function(address, message) {
        // check what message came in
        var sFirstLetter = message.substr(0, 1);
        if (sFirstLetter === "A") {
            // new unconfirmed transaction arrived
            log(getNickname(address) + ": [unconfirmed message]");

            var oTx = JSON.parse(message.substr(1));
            if (oTx.s === address) {
                oBlock.l.push(oTx);

                proofOfWorkMining(2);
            }
            

        } else if (sFirstLetter === "B") {
            // new block arrived
            log(getNickname(address) + ": [block has been found]");

            var oFoundBlock = JSON.parse(message.substr(1));
            if (verifyBlock(oFoundBlock)) {
                // TODO: add it to the blockchain

                oFoundBlock.l.forEach((oTx) => log(getNickname(oTx.s) + ": " + oTx.m));
                if (oMiningIntervalCaller !== null) {
                    clearInterval(oMiningIntervalCaller);
                }
                aBlockchain.push(oFoundBlock);
                startNewBlock();
                console.log(oBlock);
            }
        } 
        else if (sFirstLetter === "C") {
            // the new blockchain is there
            var aRecievedBlockchain = JSON.parse(message.substr(1));
            if (aRecievedBlockchain.length > aBlockchain.length) {
                // recieved blockchain is greater than one's wn
                if (!(aRecievedBlockchain.some(block => !verifyBlock(block)))) {
                    // all blocks are standalone valid
                    aBlockchain = aRecievedBlockchain;
                }
            }
            
        }
        else if (sFirstLetter === "N") {
            // a list of new nicknames arrived
            var oNickNameObject = JSON.parse(message.substr(1));
            oNickNames[oNickNameObject.k] = oNickNameObject.n;
        }
        else if (sFirstLetter === "S") {
            // a list of new nicknames arrived
            var oNickNameDirectory = JSON.parse(message.substr(1));
            for (const [sAddress, sRelatedNickName] of Object.entries(oNickNameDirectory)) {
                oNickNames[sAddress] = sRelatedNickName;
            }
        }
        else {
            log(getNickname(address) + ": " + message);
        }
  });

  document.getElementById("input").onkeydown = function(ev) {
    if (ev.keyCode == 13) {
      if (b.lastwirecount) {
        
        var oChat = Object.assign({}, oChatInterface);
        oChat.s = publicAddress;
        oChat.r = "all";
        oChat.m = ev.target.textContent;
        oChat.c = 10;

        var oTx = createTxHash(oChat, privateKey);
        console.log(oTx);
        b.send("A" + JSON.stringify(createTxHash(oChat, privateKey)));
        //oBlock.l.push(oTx);

        proofOfWorkMining(2);


        ev.target.textContent = "";
      }
      ev.preventDefault();
    }
  }

</script>
</html>
