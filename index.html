<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta content="width=device-width, initial-scale=1" name="viewport">
	<title>Chunkchain - Blockchain Try Out</title>
	<link href="style.css" rel="stylesheet" />
	<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
	<script>
		// reference to scope to outside
		let fnScope = null;

		// nickname instead of key
		//const sUserNickName = prompt("Dein Nickname", "");

		function log(message) {
			console.log(message);
		}
	</script>
	<script src="https://chr15m.github.io/bugout/bugout.min.js" type="application/javascript"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/crypto-js.min.js"></script>
	<script src="https://momentjs.com/downloads/moment.js"></script>

	<script src="https://cdn.jsdelivr.net/gh/mathusummut/confetti.js/confetti.min.js"></script>

	<script src="./logic.js" type="application/javascript"></script>
	<script src="./chat.js" type="application/javascript"></script>

	<script>
		angular.module('chunkchain', [])
			.controller('ChatController', ['$scope', function ($scope) {
				// view options and selections
				$scope.chatVisible = true;
				$scope.deepDiveVisible = false;

				// related to chat functionality
				$scope.selection = {
					activityIndicator: false,
					encryptMessageFlag: false,
					isMining: true
				};

				// conversation panel in chat
				$scope.selectedConversation = 'all';
				$scope.activeConversations = [{
					name: 'all',
					lastMsg: 1614584104 // fallback date in the past
				}]

				// chat messages and token
				$scope.tokenPerMessage = 1;
				$scope.currentMessage = "";

				// lists of feed activities and messages in current conversation
				$scope.feedNews = [];
				$scope.messagesList = [];

				// inital start: 10 token
				$scope.token = 10;

				// red bubble for blockchain view about new messages
				$scope.noOfNewMessages = 0;

				// new messages grouped by convo
				$scope.newMessages = {};

				// related to deep-dive
				$scope.levelList = {
					0: {
						0: 'Überblick',
						1: 'Unser Netzwerk',
						2: 'Wo sind die Daten?',
						3: 'Sind die Daten echt?'
					},
					1: {
						0: 'Was ist ein Hash?',
						1: 'Was ist Verschlüsselung?',
						2: 'Was schicken wir uns?',
						3: 'Wo sind die Nachrichten?'
					},
					2: {
						0: 'Was ist ein Block?',
						1: 'Wie sieht ein Block aus?',
						2: 'Wie entsteht ein Block?',
						3: 'Wie entsteht die Kette?'
					},
					3: {
						0: 'Wie kann ich verschlüsseln?',
						1: 'Soll ich Blöcke suchen?',
						2: 'Kann ich löschen?',
						3: 'Wie finden wir Konsens?'
					},
					4: {
						0: 'Wie wird die Blocksuche geregelt?',
						1: 'Was sind unbestätigte Nachrichten?',
						2: 'Kann ich Daten manipulieren?'
					}
				};

				// level names
				$scope.levelDesc = {
					0: 'Level 1: Einsteiger',
					1: 'Level 2: Anfänger',
					2: 'Level 3: Fortgeschritten',
					3: 'Level 4: Profi',
					4: 'Level 5: Voll-Profi'
				}

				// token rewards per completion of mission, and f for full level
				$scope.levelRewards = {
					0: {
						0: 2, // Token
						1: 2,
						2: 2,
						3: 2,
						f: 4
					},
					1: {
						0: 3, // Token
						1: 3,
						2: 3,
						3: 3,
						f: 8
					},
					2: {
						0: 3, // Token
						1: 3,
						2: 3,
						3: 3,
						f: 10
					},
					3: {
						0: 5, // Token
						1: 5,
						2: 5,
						3: 5,
						f: 10
					},
					4: {
						0: 5, // Token
						1: 5,
						2: 5,
						3: 5,
						f: 20
					}
				}

				// current active levels and missions
				$scope.selectedLevel = 0;
				$scope.selectedMission = 0;

				// welcoming 
				$scope.welcomeContentIndex = 0;
				$scope.nicknameInput = "";

				// models for interactive encryption mission
				$scope.symText = "Mein Text";
				$scope.symKey = "Schlüssel";
				$scope.symEncrypt = "";
				$scope.symDecryptKey = $scope.symKey;
				$scope.keyPair = {};
				$scope.keyPairOutput = {
					publicKey: "",
					privateKey: ""
				};
				$scope.asymInputText = "";
				$scope.asymOutputText = "";

				// interactive key
				$scope.coins = 1;
				$scope.publicKey = "6c157587185fd2";
				$scope.privateKey = "6c157587185fd2";

				// for delete mission
				$scope.deleteChoice = "-";

				// for missions of seeing a deep-dive into a block
				$scope.selectedBlock = Object.assign({}, oBlockInterface);
				// select field options
				$scope.availableBlocks = [0];
				$scope.blockchain = [];
				$scope.selectedBlockNumber = 0;

				// nonce models for input field and simulation of PoW
				$scope.nonceInput = "";
				$scope.nonceInputPoW = "";

				// acomplishments for badge on header
				$scope.highestAchievement = null;

				$scope.continueWelcome = function () {
					$scope.welcomeContentIndex += 1;
				}
				$scope.nicknameGiven = function (sNickname) {
					sUserNickName = sNickname;
					startConnection(registerHandlers);
					$scope.welcomeContentIndex += 1;
				}
				$scope.completeWelcome = function () {
					var oWelcomeModal = document.getElementById("welcomeModal");
					oWelcomeModal.style.display = "none";
				}

				$scope.exportCryptoKey = async function () {
					let exported = await window.crypto.subtle.exportKey(
						"spki",
						$scope.keyPair.publicKey
					);
					$scope.keyPairOutput.publicKey = arrayBufferToBase64String(exported);

					exported = await window.crypto.subtle.exportKey(
						"pkcs8",
						$scope.keyPair.privateKey
					);
					$scope.keyPairOutput.privateKey = arrayBufferToBase64String(exported);
				}


				$scope.generateKeyPair = function () {
					window.crypto.subtle.generateKey({
							name: "RSA-OAEP",
							// Consider using a 4096-bit key for systems that require long-term security
							modulusLength: 2048,
							publicExponent: new Uint8Array([1, 0, 1]),
							hash: "SHA-256",
						},
						true,
						["encrypt", "decrypt"]
					).then((keyPair) => {
						$scope.keyPair = keyPair;
						$scope.exportCryptoKey();
					});
				};

				// generate at init a key pair for encryption mission
				$scope.generateKeyPair();

				$scope.asymEncryptMessage = function (sText) {
					if ($scope.keyPair.hasOwnProperty("privateKey")) {
						window.crypto.subtle.encrypt({
								name: "RSA-OAEP"
							},
							$scope.keyPair.publicKey,
							textToArrayBuffer(sText)
						).then(ciphertext => {
							let buffer = new Uint8Array(ciphertext);
							$scope.asymOutputText = arrayBufferToString(buffer);
						});

					}
					$scope.asymOutputText = "";
				};

				// general functions to switch the views
				$scope.switchToBlockchain = function () {
					$scope.chatVisible = false;
					$scope.deepDiveVisible = true;
				}
				$scope.switchToChat = function () {
					$scope.chatVisible = true;
					$scope.deepDiveVisible = false;
				}

				// functions for chatting
				$scope.miningHasChanged = function () {
					if ($scope.selection.isMining) {
						startMining(b);
					} else {
						stopMining(b);
					}
				};

				// new convo selected and refresh the messages
				$scope.conversationSelected = function (sSelectedItem) {
					$scope.selectedConversation = sSelectedItem;
					$scope.msgArrived(true, null);
					// remove potential flags for new messages 
					delete $scope.newMessages[sSelectedItem];
					$scope.noOfNewMessages = Object.values(fnScope.newMessages).reduce((a, b) => a + b, 0);
				};

				$scope.newParticipant = function (sNickname) {
					$scope.feedNews.push({
						'type': '+',
						'actor': sNickname,
						'time': moment().format("hh:mm:ss")
					});
				};

				$scope.participantLeft = function (sNickname) {
					$scope.activeConversations = $scope.activeConversations.filter(convo => convo.name !==
						sNickname)
					$scope.feedNews.push({
						'type': '-',
						'actor': sNickname,
						'time': moment().format("hh:mm:ss")
					});
				};

				// show popup
				$scope.newConvo = function () {
					var modal = document.getElementById("popupModal");
					modal.style.display = "block";
				}

				$scope.newMessage = function (sNickname, oTimestamp) {
					$scope.feedNews.push({
						'type': 'MSG',
						'actor': sNickname,
						'time': moment(oTimestamp).format("hh:mm:ss"),
						'id': 'MSG' + sNickname + moment(oTimestamp).format("hh:mm:ss:SSS")
					});
					$scope.msgArrived(false, oTimestamp);
				};

				$scope.newAccomplishment = function (sNickname, sKey) {
					$scope.feedNews.push({
						'type': 'U',
						'actor': sNickname,
						'time': moment().format("hh:mm:ss"),
						'badge': oBadges[sKey],
						'id': 'U' + sNickname + moment().format("hh:mm:ss:SSS")
					});
				};

				$scope.blockFound = function (sNickname, bSelfFlag, iMessages, sNonce, iBlockNumber) {
					if (bSelfFlag) {
						$scope.feedNews.push({
							'type': 'S',
							'nonce': sNonce,
							'time': moment().format("hh:mm:ss"),
							'id': 'S' + moment().format("hh:mm:ss:SSS")
						});
					} else {
						$scope.feedNews.push({
							'type': 'B',
							'actor': sNickname,
							'n': iMessages,
							'b': iBlockNumber,
							'time': moment().format("hh:mm:ss"),
							'id': 'B' + sNickname + moment().format("hh:mm:ss:SSS")
						});
					}
					$scope.msgArrived(true);
				};

				// message arrived feature
				// either refresh at new entire block or at convo change
				// otherwise delta updates based on UXTO
				$scope.msgArrived = function (bEntireRefresh, oTimestamp) {
					var fnFilter;
					if ($scope.selectedConversation === "all") {
						fnFilter = (tx) => tx.r === "all";
					} else {
						var sRecipient = Object.keys(oNickNames).find(key => oNickNames[key] === $scope
							.selectedConversation)
						fnFilter = (tx) => (tx.r === publicAddress && tx.s === sRecipient) || (tx.s ===
							publicAddress && tx.r === sRecipient);
					}
					if (bEntireRefresh) {
						$scope.messagesList = aBlockchain.map(block => block.l)
							.flat().filter(fnFilter)
							.map(tx => {
								return {
									'd': (tx.s === publicAddress) ? 's' : 'r', // direction - recieving
									's': tx.s,
									'm': decryptMsg(tx),
									't': tx.t,
									'u': false,
									'b': tx.b
								}
							}).concat(
								oBlock.l.filter(fnFilter)
								.map(tx => {
									return {
										'd': (tx.s === publicAddress) ? 's' : 'r', // direction - recieving
										's': tx.s,
										'u': true,
										't': tx.t,
										'm': ""
									}
								})
							);
					} else {
						var aMessages = oBlock.l.filter(tx => tx.t === oTimestamp).filter(fnFilter)
							.map(tx => {
								return {
									'd': (tx.s === publicAddress) ? 's' : 'r', // direction - recieving
									's': tx.s,
									'u': true,
									't': tx.t,
									'm': ""
								}
							});
						aMessages.forEach(item => $scope.messagesList.push(item));
					}
				}

				$scope.onSendChatMessage = function (e) {
					e.preventDefault();
					if ($scope.token > $scope.tokenPerMessage) {
						sendMessage($scope.currentMessage, $scope.selectedConversation, $scope.tokenPerMessage);
						$scope.currentMessage = "";
						$scope.token -= $scope.tokenPerMessage;
						$scope.activeConversations.filter(convo => convo.name === $scope.selectedConversation)
							.lastMsg = moment().unix();
					} else {
						// Error-Token
						alert("Nicht genug Tokens. Verdien dir welche ;-)");
					}
				};
				$scope.getNonConvoParticipants = function () {
					var aParticipants = Object.values(oNickNames);
					return (aParticipants.filter(n => !$scope.activeConversations.map(convo => convo.name)
						.includes(n) && n !== sUserNickName));
				}
				$scope.newConvoSelected = function (sName) {
					if ($scope.activeConversations.filter(convo => convo.name === sName).length === 0) {
						$scope.activeConversations.push({
							name: sName,
							lastMsg: moment().unix()
						});
						$scope.selectedConversation = sName;
						$scope.msgArrived(true);
					}

					var modal = document.getElementById("popupModal");
					modal.style.display = "none";
				}
				$scope.formatTime = function (iTimestamp) {
					return moment(iTimestamp).format('LTS');
				}
				$scope.getNickname = function (sAddress) {
					return getNickname(sAddress);
				}

				// functions for deep-dive
				$scope.missionSelected = function (sSelectedItem) {
					$scope.selectedMission = parseInt(sSelectedItem);
				};
				$scope.hash = function (sInput) {
					return CryptoJS.SHA1(sInput).toString();
				};
				$scope.encrypt = function (sInput, sKey) {
					const encrypt = vignereEncrypt(sInput, sKey);
					if ($scope.symEncrypt === "") {
						$scope.symEncrypt = encrypt;
					}
					return encrypt;
				};
				$scope.decrypt = function (sInput, sKey) {
					if (sInput !== "") {
						return vignereDecrypt(sInput, sKey);
					}
					return "";
				}
				$scope.timestamp = function () {
					return moment().unix();
				}
				$scope.hashTx = function () {
					const sComboundString = $scope.publicKey + "all" + $scope.messageSimulation + $scope.coins +
						$scope.timestamp();
					const sHashString = CryptoJS.enc.Hex.stringify(CryptoJS.SHA1(sComboundString.toString()));
					return sHashString;
				}
				$scope.hashTxSigned = function () {
					return CryptoJS.AES.encrypt($scope.hashTx(), $scope.privateKey).toString();
				}
				$scope.missionCompleted = function () {
					var aArray = $scope.levelList[$scope.selectedLevel];
					if ($scope.selectedMission + 1 >= Object.keys(aArray).length) {
						// end of level
						var aLevels = Object.keys($scope.levelList);

						if ($scope.selectedLevel + 1 >= aLevels.length) {
							// complete finished
							confetti.start(5000, 700);
							$scope.showTokenIncrease(20);
							$scope.token += 20;
							$scope.showBadgeReward("Mission accomplished: Du hast dir das " + oBadges.L5 +
								" verdient.");
							shareAccomplishment("L5");
						} else {
							// check for rewards
							if ($scope.levelRewards[$scope.selectedLevel].hasOwnProperty("f")) {
								$scope.showTokenIncrease($scope.levelRewards[$scope.selectedLevel].f);
								$scope.token += $scope.levelRewards[$scope.selectedLevel].f;
								confetti.start(2000, 200);
								delete $scope.levelRewards[$scope.selectedLevel].f;

								$scope.switchToChat();

								if ($scope.selectedLevel === 1) {
									// Level 2 complete
									$scope.showBadgeReward("Mission accomplished: Du hast dir das " + oBadges.L2 +
										" verdient.");
									shareAccomplishment("L2");
								}
							}

							$scope.selectedLevel += 1;
							$scope.selectedMission = 0;
						}
					} else {
						// check for rewards
						if ($scope.levelRewards[$scope.selectedLevel].hasOwnProperty($scope.selectedMission)) {
							$scope.showTokenIncrease($scope.levelRewards[$scope.selectedLevel][$scope
								.selectedMission
							]);
							$scope.token += $scope.levelRewards[$scope.selectedLevel][$scope.selectedMission];
							confetti.start(1000, 50);
							delete $scope.levelRewards[$scope.selectedLevel][$scope.selectedMission];
						}

						$scope.selectedMission += 1;
					}
				}
				$scope.showTokenIncrease = function (delta) {
					var elm = document.querySelector(".fade_content");
					var btn = document.querySelector("#completionBtn");
					document.querySelector(".badge__label").innerText = "+" + delta;
					elm.style.display = "block";
					btn.disabled = true;
					setTimeout(() => {
						elm.style.display = "none";
						btn.disabled = false;
					}, 5500);
				}
				$scope.showBadgeReward = function (text) {
					var elm = document.querySelector(".push");
					elm.innerText = text;
					elm.style.display = "block";
					setTimeout(() => {
						elm.style.display = "none";
					}, 6000);
				}
				$scope.getBlocks = function () {
					return aBlockchain.map(block => block.b).flat();
				}
				$scope.setBlock = function () {
					$scope.selectedBlockNumber = parseInt(document.querySelector('#selectedBlockNumber').value,
						10);
					$scope.selectedBlock = aBlockchain[$scope.selectedBlockNumber];
				}
				$scope.clickOnBlock = function (blockId) {
					$scope.selectedBlockNumber = aBlockchain[blockId];
					$scope.selectedBlock = aBlockchain[$scope.selectedBlockNumber];
					$scope.selectedLevel = 2;
					$scope.selectedMission = 1;
					$scope.chatVisible = false;
					$scope.deepDiveVisible = true;
				}
				$scope.simulateBlockHashCalculation = function (oBlock, sNonce) {
					if (oBlock && oBlock.p) {
						return _calcBlockHash(oBlock, sNonce);
					}
					return "";
				}

				$scope.simulatePoW = function (oBlock) {
					if (oBlock && oBlock.p) {
						return _calcBlockHash(oBlock, $scope.nonceInputPoW);
					}
					return "";
				}
				$scope.getFeedNews = function () {
					if ($scope.selection.activityIndicator) {
						return $scope.feedNews.filter(item => item.actor === sUserNickName || item.type == 'S')
							.reverse();
					}
					return $scope.feedNews.slice().reverse();
				}

				// overall refresh
				setInterval(function () {
					$scope.blockchain = aBlockchain;
					$scope.availableBlocks = aBlockchain.map(block => block.b).flat();
					$scope.currentBlock = aBlockchain[aBlockchain.length - 1];
					$scope.unspend = oBlock;
					bMining = $scope.selection.isMining;
					$scope.$apply();
				}, 1000);

				fnScope = $scope;

				var oModal = document.getElementById("popupModal");
				var oSpan = document.getElementsByClassName("close")[0];
				
				window.onclick = function (event) {
					if (event.target == oModal) {
						oModal.style.display = "none";
					}
				};
				oSpan.onclick = function () {
					oModal.style.display = "none";
				};	
			}])
			.directive('scrollToBottom', function ($timeout, $window) {
				return {
					scope: {
						scrollToBottom: "="
					},
					restrict: 'A',
					link: function (scope, element, attr) {
						scope.$watchCollection('scrollToBottom', function (newVal) {
							if (newVal) {
								$timeout(function () {
									element[0].scrollTop = element[0].scrollHeight;
								}, 0);
							}

						});
					}
				};
			});
	</script>

</head>

<body ng-app="chunkchain" ng-controller="ChatController">

	<div class="header">
		<img src="assets/ChunkChain_Logo.svg" width="200px" />

		<div class="header_items">
			<a ng-show="chatVisible"
				ng-click="switchToBlockchain()">{{ levelRewards[1][0] === 2 ? 'weiter deep-diven' : 'wie es funktioniert' }}</a>
			<a ng-show="deepDiveVisible" ng-click="switchToChat()">wieder chatten
				<span class="button__badge {{ noOfNewMessages === 0 ? 'hidden' : '' }}"
					ng-show="{{ noOfNewMessages > 0 }}">{{ noOfNewMessages }}</span>
			</a>
			<span>dein Kontostand: <b>{{ token }} Token</b>
				{{ highestAchievement === 'L2' ? '&#129352;' : (highestAchievement === 'L5' ? '&#129351;' : '') }}</span>
		</div>
	</div>

	<div class="main_body">
		<div ng-show="chatVisible">
			<h1 class="page_title">Chat</h1>
			<p class="introduction_section" ng-if="levelRewards[3][0] === 5">
				Aktuell nutzen wir eine <b>public blockchain</b> (jeder darf schreiben und lesen) und speichern
				<b>on-chain</b> (alle Daten in der Blockchain). <br />
				Damit kannst du aktuell jede Nachricht lesen, die jemand in diesem Netzwerk schickt.
			</p>
			<p class="introduction_section">
				<div class="switch_container" ng-if="levelRewards[3][0] !== 5">
					<span class="{{ !selection.encryptMessageFlag ? 'switch_selected' : '' }}">unverschlüsselt</span>
					<label class="switch">
						<input type="checkbox" ng-model="selection.encryptMessageFlag" />
						<span class="slider"></span>
					</label>
					<span class="{{ selection.encryptMessageFlag ? 'switch_selected' : '' }}">Nachrichten
						verschlüsseln</span>
				</div>
			</p>

			<div class="chat_container">
				<div class="chat_window">
					<div class="conversations_container">
						<p ng-repeat="convo in activeConversations | orderBy : '-lastMsg'"
							class="conversation {{ convo.name === selectedConversation ? 'selected' : '' }}"
							data-letters="{{ convo.name.substr(0, 1).toUpperCase() }}"
							ng-click="conversationSelected(convo.name)">
							{{ convo.name }}
							<span
								class="{{ (newMessages[convo.name] && newMessages[convo.name] > 0) ? 'dot' : '' }}"></span>
						</p>
					</div>
					<div class="messages_container" style="overflow: scroll; height: 500px;"
						scroll-to-bottom="messagesList">
						<div ng-repeat="message in messagesList track by $index"
							class="message {{ message.d === 's' ? 'sent ' : '' }}{{ message.u === true ? 'unspend' : '' }}">
							<span ng-if="selectedConversation === 'all' && message.d === 'r' " class="sender"
								title="{{ message.u ? 'Nachricht muss erst in einen Block gefasst werden' : '' }}">{{ getNickname(message.s) }}</span>
							{{ message.u ? 'warten auf Nachricht...' : message.m }} <span
								class="message_time">{{ message.b ? '&#128274; ' : '' }}{{ formatTime(message.t) }}</span>
						</div>
					</div>
				</div>
				<div class="background_activity">
					<h3 class="minor_title">Aktivitäten im Netzwerk</h3>
					<div class="switch_container">
						<span class="{{ !selection.activityIndicator ? 'switch_selected' : '' }}">alle</span>
						<label class="switch">
							<input type="checkbox" ng-model="selection.activityIndicator" />
							<span class="slider"></span>
						</label>
						<span class="{{ selection.activityIndicator ? 'switch_selected' : '' }}">nur meine
							Aktivitäten</span>
					</div>
					<div class="activity_feed">
						<div class="activity_item"
							ng-repeat="feedItem in getFeedNews() track by feedItem.id">
							<div ng-if="feedItem.type == '+' ">
								<span class="time">{{ feedItem.time }}</span><b
									ng-click="newConvoSelected(feedItem.actor)"
									class="hoverable">{{ feedItem.actor }}</b> ist dem Netzwerk
								beigetreten.
							</div>
							<div ng-if="feedItem.type == '-' ">
								<span class="time">{{ feedItem.time }}</span><b>{{ feedItem.actor }}</b> hat das
								Netzwerk
								verlassen.
							</div>
							<div ng-if="feedItem.type == 'M+' ">
								<span class="time">{{ feedItem.time }}</span><b>{{ feedItem.actor }}</b> sucht jetzt
								auch
								nach Blöcken (mining).
							</div>
							<div ng-if="feedItem.type == 'M-' ">
								<span class="time">{{ feedItem.time }}</span><b>{{ feedItem.actor }}</b> hat die Suche
								nach
								Blöcken aufgegeben.
							</div>
							<div ng-if="feedItem.type == 'B' ">
								<span class="time">{{ feedItem.time }}</span><b>{{ feedItem.actor }}</b> hat einen <span
									class="hoverable" ng-click="clickOnBlock(feedItem.b)">neuen
									Block</span> gefunden für <b>{{ feedItem.n }}</b> Nachrichten.
							</div>
							<div ng-if="feedItem.type == 'S' ">
								<span class="time">{{ feedItem.time }}</span>Du hast einen Block gefunden.
								<b>{{ feedItem.nonce }}</b> ist die Lösung
							</div>
							<div ng-if="feedItem.type == 'MSG' ">
								<span class="time">{{ feedItem.time }}</span><b>{{ feedItem.actor }}</b> hat eine
								Nachricht
								geschrieben.
							</div>
							<div ng-if="feedItem.type == 'U' ">
								<span class="time">{{ feedItem.time }}</span><b>{{ feedItem.actor }}</b> hat das
								{{ feedItem.badge }} verdient.
							</div>
						</div>
					</div>

				</div>
				<div class="chat_window_footer">
					<div class="chat_window_footer_new_chat_container">
						<button class="button" ng-click="newConvo()">neuer Chat</button>
					</div>
					<div class="chat_window_footer_message">
						<input type="number" size="1" maxlength="2" ng-model="tokenPerMessage" />
						Token
						<div class="flexible_grow"></div>
						<form ng-submit="onSendChatMessage($event)">
							<input type="text" size="40" maxlength="300" placeholder="Nachricht..."
								ng-model="currentMessage" />
							<button class="button" [disabled]="currentMessage !== ''">senden</button>
						</form>
					</div>
				</div>
			</div>

		</div>


		<div class="background_container" ng-show="deepDiveVisible">
			<div class="level_container">
				<select ng-options="level*1 as data for (level, data) in levelDesc track by level*1" ng-model="selectedLevel"></select>
				<!--{{ levelDesc[selectedLevel] }}-->

				<div class="mission_container">
					<div ng-repeat="(mission, desc) in levelList[selectedLevel]"
						class="{{ mission*1 === selectedMission ? 'selected_mission' : 'mission' }}"
						ng-click="missionSelected(mission)">
						{{ desc }}
					</div>
				</div>
			</div>

			<div class="info_container">
				<h1 class="page_title">{{ levelList[selectedLevel][selectedMission] }}</h1>
				<div ng-if="selectedLevel == 0 && selectedMission == 0 ">
					<p class="introduction_section">
						Willkommen bei unserer Blockchain-Simulation.<br />
						Du wirst hier interaktiv Teilnehmer eines Chat-Netzwerks sein.<br />
						Dieses läuft tatsächlich auch auf einer Blockchain.
						Du wirst jederzeit die Gelegenheit haben, mit anderen zu chatten. <br /><br />
						Du kannst währenddessen Missionen erfüllen, und dir eine echte Blockchain aus verschiedenen
						Winkeln anschauen.<br />
						Am Ende jeder Mission hast du unten einen Button mit "Mission abschliessen". <br /><br />
						Also worauf wartest du? Let's go!
					</p>
				</div>
				<div ng-if="selectedLevel == 0 && selectedMission == 1 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Unser Chat-System läuft auf einem <b>verteilten System</b>. Aber was ist das?<br />
									Unten siehst du eine klassische Client-Server-Architektur wie du sie aus Chat-Apps
									wie WhatsApp kennst.<br />
									Normalerweise schicken wir die Nachrichten an einen Server und dieser leitet sie
									dann weiter.<br />
								</td>
								<td>
									Bei uns sind das anders aus. Wie du siehst, gibt es kein Server. Jeder kommuniziert
									direkt mit jedem.<br />
									Da wir alle gleichwertig in diesem Netzwerk sind, reden wir gar nicht mehr von
									Client oder Server, sondern von <b>Peers</b>.<br />
									Wir sind alle Peers, weswegen uns das zu einem Peer-to-Peer-Netzwerk macht aka
									P2P.<br />
								</td>
							</tr>
							<tr>
								<td class="center_image">
									<img src="./assets/Client_Server.svg" />
								</td>
								<td class="center_image">
									<img src="./assets/P2P_Network.svg" />
								</td>
							</tr>
						</table>

						<br />

					</p>
				</div>
				<div ng-if="selectedLevel == 0 && selectedMission == 2 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Tatsächlich ist das eine gute Frage und gar nicht so einfach.<br />
									Schauen wir uns da noch einmal die klassische Client-Server-Architektur an.<br />
									Hier werden alle Daten auf dem Server in einer zentralen Datenbank
									gespeichert.<br />
								</td>
								<td>
									Und hier speichern wir tatsächlich <i>alle</i> Daten auf <i>allen</i>
									Peer-Rechnern.<br />
									Diese Redundanz ist bewusst erzeugt, um das System stabiler zu machen.<br />
									Fällt ein Rechner aus, sind genug andere noch da. Doch das Ganze hat auch
									Nachteile.<br />
								</td>
							</tr>
							<tr>
								<td class="center_image">
									<img src="./assets/Client_Server_Data.svg" />
								</td>
								<td class="center_image">
									<img src="./assets/P2P_Network_Data.svg" />
								</td>
							</tr>
						</table>

						<br />

					</p>
				</div>
				<div ng-if="selectedLevel == 0 && selectedMission == 3 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Auch das ist eine sehr gute Frage.<br />
									Bei klassischen Client-Server-Architekturen sind die Daten zentral auf dem
									Server.<br />
									Wir vertrauen also diesem Server, dass die Daten echt sind.<br />
									Das machen wir sehr häufig. Wir vertrauen Services wie Amazon, PayPal, Instagram
									tagtäglich.<br />
								</td>
								<td>
									Was ist aber wenn wir keine zentrale Instanz haben, der wir vertrauen können?<br />
									Das P2P Network erzeugt bewusst Redundanz, sodass wir nicht einer einzelnen Person
									vertrauen müssen.<br />
									Stattdessen vertrauen wir dem gesamten System und überprüfen uns gegenseitig.<br />
									Das bedeutet aber auch, dass wir uns auf jede noch so kleine Information gemeinsam
									einigen müssen (<b>Konsens</b>).<br />
								</td>
							</tr>
							<tr>
								<td class="center_image">
									<img src="./assets/Client_Server_Data.svg" />
								</td>
								<td class="center_image">
									<img src="./assets/P2P_Network_Data.svg" />
								</td>
							</tr>
						</table>

						<br />

					</p>
				</div>

				<div ng-if="selectedLevel == 1 && selectedMission == 0 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Ein Hash ist eine Möglichkeit eine Zeichenkette (String) zu komprimieren.<br />
									Wenn wir einen String hashen, bekommen wir immer einen neuen String einer fixen
									Länge raus.<br />
									Dabei ist egal, wie lang der anfängliche String ist, es kommt immer die gleiche
									Länge vom Hash raus.<br /><br />

									Hashes haben dabei drei wesentliche Eigenschaften:
									<ul>
										<li>Aus einem Hash ist es unmöglich den orginalen String zurückzubekommen</li>
										<li>Es ist unmöglich aus einem String-Hash-Paar einen weiteren String mit dem
											gleichen Hash zu finden</li>
										<li>Es ist unmöglich zwei Strings zu finden, die den gleichen Hash haben</li>
									</ul>
								</td>
								<td>
									Der Vorteil ist, Hashes sind leicht zu speichern und man kann so Daten
									überprüfen.<br />
									Änderst du nur einen Buchstaben im orginalen String, sieht der Hash komplett anders
									aus.<br /><br />

									Willst du es ausprobieren, z.B. SHA1 (Secure Hash Algorithm):<br />
									<input type="text" size="60" placeholder="Gib deinen Text ein..."
										ng-model="hashInput" /> <br /><br />
									Hash: <b>{{ hash(hashInput) }}</b>
								</td>
							</tr>
						</table>

						<br />

					</p>
				</div>
				<div ng-if="selectedLevel == 1 && selectedMission == 1 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Die <b>symmetrische</b> Verschlüsselung verschlüsselt und entschlüsselt mit
									dem gleichen Schlüssel.<br />
									Das ist ähnlich wie bei einem Haustürschloss. Du kannst deinen Schlüssel nutzen, um
									die Tür aufzumachen und abzuschliessen.<br /><br />
								</td>
								<td>
									Bei einer <b>asymmetrischen</b> Verschlüsselung hast du einen privaten Schlüssel
									(<b>private key</b>) und einen öffentlichen (<b>public
										key</b>).<br />
									Um ein solches Schlüssel-Paar zu erzeugen, generierst du einen private key und
									leitest einen public key davon ab.<br />
									Man kann von einem public key nie den dazugehörigen private key erraten.
								</td>
							</tr>
							<tr>
								<td>
									<div class="form">
										Nachricht: <input type="text" size="50" ng-model="symText" /> <br /><br />
										Dein Schlüssel: <input type="text" size="50" ng-model="symKey" /> <br /><br />
										Verschlüsselte Nachricht: <b>{{ encrypt(symText, symKey) }}</b>
									</div>
									<br />
									<hr /><br />
									Zum Entschlüsseln:
									<div class="form">
										Verschlüsselte Nachricht: <input type="text" size="50" ng-model="symEncrypt" />
										<br /><br />
										Dein Schlüssel: <input type="text" size="50" ng-model="symDecryptKey" />
										<br /><br />
										Entschlüsselte Nachricht: <b>{{ decrypt(symEncrypt, symDecryptKey) }}</b>
									</div>
								</td>
								<td>
									<div class="form">
										Nachricht: <input type="text" size="50" ng-model="asymInputText"
											ng-change="asymEncryptMessage(asymInputText)" /> <br /><br />
										public key: <div class="key">{{ keyPairOutput.publicKey }}</div> <br /><br />
										Verschlüsselte Nachricht: <b>{{ asymOutputText }}</b>
									</div>
									<br />
									<hr /><br />
									Zum Entschlüsseln:
									<div class="form">
										private key: <div class="key">{{ keyPairOutput.privateKey }}</div>
										<br /><br />
										entschlüsselt: <b>{{ asymInputText }}</b>
									</div>
								</td>
							</tr>
						</table>

						<br />

					</p>
				</div>
				<div ng-if="selectedLevel == 1 && selectedMission == 2 ">
					<p class="introduction_section">
						Du kannst das mal interaktiv ausprobieren, indem du eine Nachricht mal schreibst. <br />
						Diese Nachricht wird als eine Transaktion geschickt. Dabei werden weitere Informationen, wie Sender, Empfänger, Zeitstempel, ... angehängt.<br />
						Wie du aus dem Unterricht gelernt hast, wird auch der Hash erzeugt und mit deinem private key verschlüsselt. <br /><br />
						Dabei sieht die Struktur wie folgt aus:

						<ul class="flow">
							<li><b>Orginale Transaktion</b> <br /><br />
								{<br />
								<span class="attribute">Absender:</span> "{{ publicKey }}",<br />
								<span class="attribute">Empfänger:</span> "all",<br />
								<span class="attribute">Nachricht:</span> "<input type="text" size="10"
									ng-model="messageSimulation" />",<br />
								<span class="attribute">Kosten:</span> {{ coins }}<br />
								}<br />
							</li>
							<li><b>mit Zeitstempel dazu</b> <br /><br />
								{<br />
								<span class="attribute">sender:</span> "{{ publicKey }}",<br />
								<span class="attribute">recipient:</span> "all",<br />
								<span class="attribute">message:</span> "{{ messageSimulation }}",<br />
								<span class="attribute">coins:</span> {{ coins }}<br />
								<span class="attribute">time:</span> <span
									class="highlighted">{{ timestamp() }}</span><br />
								}<br />
							</li>
							<li><b>Hash hinzufügen</b> <br /><br />
								{<br />
								<span class="attribute">sender:</span> "{{ publicKey }}",<br />
								<span class="attribute">recipient:</span> "all",<br />
								<span class="attribute">message:</span> "{{ messageSimulation }}",<br />
								<span class="attribute">coins:</span> {{ coins }}<br />
								<span class="attribute">time:</span> {{ timestamp() }}<br />
								<span class="attribute">hash:</span>
								<div class="cut-text">{{ hashTx() }}</div><br />
								}
							</li>
							<li><b>Hash signieren mit deinem private key</b> <br /><br />
								{<br />
								<span class="attribute">sender:</span> "{{ publicKey }}",<br />
								<span class="attribute">recipient:</span> "all",<br />
								<span class="attribute">message:</span> "{{ messageSimulation }}",<br />
								<span class="attribute">coins:</span> {{ coins }}<br />
								<span class="attribute">time:</span> {{ timestamp() }}<br />
								<span class="attribute">hash:</span>
								<div class="cut-text">{{ hashTxSigned() }}</div><br />
								}
							</li>
							<li><b>ins Netzwerk</b></li>
						</ul>
					</p>
				</div>
				<div ng-if="selectedLevel == 1 && selectedMission == 3 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Dazu müssen wir uns nur unser P2P (Peer-to-Peer)-Netzwerk anschauen.<br />
									Wir haben hier extra Redundanz, sodass das System robuster wird.<br />
									Also hat auch jeder eine vollständige Kopie der Daten (also ein Backup).<br />
									Das kann natürlich ziemlich schnell, ziemlich gross werden, weswegen es auch
									inzwischen auch andere Lösungen gibt.<br /><br />
									In unserem Fall speichern wir jede Transaktion bei jedem Peer. <br />
									Das heisst, du kannst auch immer sehen, wer wem was geschrieben hat.
								</td>
								<td class="center_image">
									<img src="./assets/P2P_Network_Data.svg" />
								</td>
							</tr>
						</table>

						<br />

					</p>
				</div>

				<div ng-if="selectedLevel == 2 && selectedMission == 0 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Bisher hast du einiges gelernt zu unserem P2P-Netzwerk und zu Hashes und
									Verschlüsselung.<br />
									Nachrichten sind immer Transaktionen und enthalten viele Informationen und den
									signierten Hash.<br /><br />

									Wie du ebenfalls zuvor gesehen hast, müssen wir uns in einem P2P-Netzwerk auf jede
									Information einigen.<br />
									Das würde sehr viel Abstimmung bedeuten.<br />
									Stattdessen sammeln wir neue Daten einfach in einem Pool (<b>unconfirmed
										transactions</b>).<br />
									Nun kann sich jemand der Aufgabe stellen, einige dieser Transaktionen zu sammeln und
									zur Abstimmung bringen.<br /><br />

									Der Vorgang einen Block zur Abstimmung zu bringen, benötigt viel Aufwand.<br />
									Das siehst du gleich.
								</td>
								<td class="center_image">
									<img src="./assets/P2P_Network_Data.svg" />
								</td>
							</tr>
						</table>

						<br />

					</p>
				</div>
				<div ng-if="selectedLevel == 2 && selectedMission == 1 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Ein Block ist eine Ansammlung an Transaktionen. <br />
									Sobald ein Block bestätigt ist, hat jeder Teilnehmer im P2P-Netzwerk die Info, dass
									dieser Block wahre Daten enthält. <br /><br />

									Ein Block besteht dabei aus einem <b>block body</b> und <b>block header</b>.<br />
									Der Body enthält nur die Liste der Transaktionen. <br /><br />

									Bisher haben wir gelernt, dass wir mit einem Hash überprüfen können, ob ein String
									verändert wurde.<br />
									Wenn wir diesen Hash signieren, können wir sogar sicherstellen, dass niemand den
									Hash ändern kann.<br />
									Aber wie können wir feststellen, dass niemand einen Block ändern kann? <br /><br />

									Dazu müssen wir von allen Transaktionshashes, einen grossen Hash (<b>block hash</b>)
									bauen.<br />
									Damit können wir super leicht feststellen, ob jetzt jemand auch nur irgendetwas
									verändert hat.<br />
									Diesen speichern wir im block header ab.<br /><br />

									Wie wir jetzt aber sicherstellen können, dass niemand diesen block hash verändert,
									siehst du in der nächsten Mission.<br />
									Du kannst dir aber zuerst mal einen x-beliebigen Block anschauen.
								</td>
								<td class="center_image">
									<select ng-change="setBlock()" id="selectedBlockNumber" ng-model="selectedBlockNumber">
										<option ng-repeat="item in availableBlocks" 
											value="{{ item }}">
											Block Nr. {{ item }}
										</option>
									</select>
									<div class="block_cover">
										Blockhash: {{ selectedBlock.h }}

										<div class="block_header">
											Blocknummer: {{ selectedBlock.b }} <br />
											Anzahl an Transaktionen: {{ selectedBlock.l.length }} <br /><br />
											gefunden von: {{ getNickname(selectedBlock.r) }} <br />
											gefunden um: {{ formatTime(selectedBlock.t) }} <br />
											Vorheriger Blockhash: {{ selectedBlock.p }}
										</div>

										<div class="block_body">
											<div ng-repeat="message in selectedBlock.l" class="block_body_item">
												<div>
													<span class="msg_sender">{{ getNickname(message.s) }} &#x2192;
														{{ getNickname(message.r) }}</span> <br />
													{{ message.m }}
												</div>
												<div style="display:right">
													<span class="msg_infos">{{ message.c }} Coins</span> <br />
													<span class="msg_infos">{{ formatTime(message.t) }}</span>
												</div>
											</div>
										</div>
									</div>
								</td>
							</tr>
						</table>

						<br />

					</p>
				</div>
				<div ng-if="selectedLevel == 2 && selectedMission == 2 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Jeder Teilnehmer kann sehr leicht prüfen, ob eine Transaktion gültig ist.
									<br />
									Gültige Transaktioneen, landen die Transaktionen in einem Pool (unconfirmed
									transaction pool). <br /><br />

									Jetzt muss sich jemand der Aufgabe stellen, einen Block zu finden.<br />
									Dabei sucht die Person die Lösung einer kryptographischen Challenge.
									<br /><br />

									Mit dem Hash der Transaktionen zusammen werden einige Informationen aus dem <b>block
										header</b>
									weiter gehasht.<br />
									Darunter sind vorallem der Blockhash des vorherigen Blocks und
									Zeitstempel.<br /><br />

									Die kryptographische Challenge liegt darin eine Zeichenkette (Nonce) in Block hinzuzufügen,
									sodass der Blockhash mit Nullen
									beginnt.<br />
									Jetzt muss jemand eine x-beliebige Zeichenfolge zu den bestehenden Daten zu finden,
									sodass der Hash mit x Nullen beginnt. <br />
									Je mehr Nullen am Anfang gefordert sind, desto schwieriger wird es. <br />
									Probier es doch mal aus!<br /><br />

									Einfaches Beispiel: <br />
									Wenn ein Blockhash mit einer Null beginnen soll, braucht man ca. 16 Versuche. <br />
									Wenn ein Blockhash mit drei Nullen beginnen soll, braucht man ca. 4096 Versuche.
									<br />
									Bei sechs Nullen, sind es schon über 16 Millionen. <br />
									Das Bitcoin-Netzwerk verlangt aktuell 19 Nullen am Anfang!
								</td>
								<td class="center_image">
									<div class="block_cover">
										Blockhash: {{ simulateBlockHashCalculation(currentBlock, nonceInput) }}

										<div class="block_header">
											Blocknummer: {{ currentBlock.b }} <br />
											Anzahl an Transaktionen: {{ currentBlock.l.length }} <br /><br />

											Vorheriger Blockhash: {{ currentBlock.p }} <br />
											Nonce: <input type="text" size="40" placeholder="Probier es aus..."
												ng-model="nonceInput" />
										</div>

										<div class="block_body">
											<div ng-repeat="message in currentBlock.l" class="block_body_item">
												<div>
													<span class="msg_sender">{{ getNickname(message.s) }} &#x2192;
														{{ getNickname(message.r) }}</span> <br />
													{{ message.m }}
												</div>
												<div style="display:right">
													<span class="msg_infos">Hash: </span> <br />
													<span class="msg_infos capped">{{ message.h }}</span>
												</div>
											</div>
										</div>
									</div>
								</td>
							</tr>
						</table>

						<br />

					</p>
				</div>
				<div ng-if="selectedLevel == 2 && selectedMission == 3 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Wie du gesehen hast wird ein Hash über block header und body gebildet.<br />
									Im Block-Header ist jeweils eine Referenz zum vorherigen Block.<br />
									Dadurch werden die Blöcke "verkettet".<br /><br />

									Vorteil des ganzen ist, es noch schwerer zu machen, die Historie zu ändern.<br />
									Es ist schon so gut wie unmöglich einen Block zu ändern.<br />
									Falls ein Angreifer einen alten Block ändern möchte, müsste er alle folgenden Blöcke
									neu finden.<br />
									Das heisst, dadurch wird das System nochmals gestärkt.
								</td>
								<td class="center_image">
									<div class="block_container">

										<div class="block" ng-repeat="block in blockchain track by block.b">
											<span class="block_hash">{{ block.h }}</span>
											<b>#{{ block.b }}</b>
											{{ formatTime(block.t) }}<br /><br />
											Vorheriger Hash: <br /><span class="hash">{{ block.p }}</span><br /><br />
											<div class="tx_container">
												<div class="tx" ng-repeat="msg in block.l track by $index"></div>
											</div>
										</div>
									
									</div>
								</td>
							</tr>
						</table>

						<br />

					</p>
				</div>

				<div ng-if="selectedLevel == 3 && selectedMission == 0 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Das ist eine gute Frage. <br />
									Wir nutzen eine public blockchain, also jeder kann teilnehmen.<br /><br />

									Das heisst auch, dass jeder die gesamte Historie sehen kann.<br />
									Da deine Nachrichten bisher in Klartext verschickt worden, kann jeder deine
									Nachrichten lesen.<br />
									Nun können wir uns den Trick der asymmetrischen Verschlüsselung zu nutze
									machen.<br /><br />

									Statt dass du selbst deinen private Key zum Verschlüsseln nimmst, nimmst du jemand
									anders sein Key.<br />
									Genauer gesagt, den public key deines Empfängers.<br />
									Denn damit kann nur er mit seinem private key deine Nachricht entschlüsseln.
								</td>
								<td class="center_image">
									<img src="./assets/Encryption.svg" /> <br />
									<div class="switch_container">
										<span
											class="{{ !selection.encryptMessageFlag ? 'switch_selected' : '' }}">unverschlüsselt</span>
										<label class="switch">
											<input type="checkbox" ng-model="selection.encryptMessageFlag" />
											<span class="slider"></span>
										</label>
										<span
											class="{{ selection.encryptMessageFlag ? 'switch_selected' : '' }}">Nachrichten
											verschlüsseln</span>
									</div>
								</td>
							</tr>
						</table>

						<br />

					</p>
				</div>
				<div ng-if="selectedLevel == 3 && selectedMission == 1 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Auch das ist wieder eine fantastische Frage. <br />
									Blöcke suchen, heisst diesen Nonce zu finden.<br /><br />

									Wir sprechen hier vom sogenannten <b>Mining</b>.<br />
									Du probierst x-beliebige random Zeichenfolgen, um den Nonce zu finden.<br />
									Das ist aber auch wahnsinnig rechenintensiv.<br /><br />

									Denn je Power du hast, desto wahrscheinlicher ist es, dass du einen Block
									findest.<br />
									Dafür bekommst du natürlich auch eine Belohnung.<br />
									Im Bitcoin-Netzwerk würdest du über 6 Bitcoin pro Block bekommen.<br /><br />

									Du musst das jetzt aber deinen Kosten gegenüber stellen (Strom + Hardware).<br />
									Das kann sehr schnell, verdammt teuer werden und sich für dich nicht mehr
									lohnen.<br /><br />

									Das Bitcoin-Netzwerk verbraucht nur durch Mining soviel Strom wie die gesamten
									Niederlande!<br />
									Klimatechnisch eine reinste Katastrophe. <br />
									<div class="switch_container">
										<span class="{{ !selection.isMining ? 'switch_selected' : '' }}">Nicht
											suchen</span>
										<label class="switch">
											<input type="checkbox" ng-model="selection.isMining"
												ng-change="miningHasChanged()" />
											<span class="slider"></span>
										</label>
										<span class="{{ selection.isMining ? 'switch_selected' : '' }}">Nach Blöcken
											suchen</span>
									</div>
								</td>
								<td class="center_image">
									<div class="block_cover">
										Blockhash: {{ simulatePoW(currentBlock) }}

										<div class="block_header">
											Blocknummer: {{ currentBlock.b }} <br />
											Anzahl an Transaktionen: {{ currentBlock.l.length }} <br />
											Vorheriger Blockhash: {{ currentBlock.p }} <br /><br />
											Nonce: <input type="text" size="40" ng-model="nonceInputPoW" disabled />
										</div>

										<div class="block_body">
											<div ng-repeat="message in currentBlock.l" class="block_body_item">
												<div>
													<span class="msg_sender">{{ getNickname(message.s) }} &#x2192;
														{{ getNickname(message.r) }}</span> <br />
													{{ message.m }}
												</div>
												<div style="display:right">
													<span class="msg_infos">Hash: </span> <br />
													<span class="msg_infos capped">{{ message.h }}</span>
												</div>
											</div>
										</div>
									</div>
								</td>
							</tr>
						</table>

						<br />

					</p>
				</div>
				<div ng-if="selectedLevel == 3 && selectedMission == 2 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Die Frage darfst du dir selbst beantworten.<br />
									Denn das ist gar nicht so trivial und viele vergessen das.<br /><br />

									Blockchains haben folgende Eigenschaften:
									<ul>
										<li>Die Daten liegen bei allen Teilnehmern</li>
										<li>Jedes kleine Stück Daten kann über Hashes verifiziert werden</li>
										<li>Dadurch kannst du nichts aus der Vergangenheit ändern</li>
										<li>Nichts ändern heisst du kannst nicht mal ein Zeichen verändern</li>
									</ul>
								</td>
								<td>
									Denkst du, du kannst die Frage beantworten<br /><br />

									Kann ich löschen:<br />
									<select ng-model="deleteChoice">
										<option value="-">-</option>
										<option value="y">ja</option>
										<option value="n">nein</option>
									</select><br /><br />

									Deine Antwort ist:
									{{ deleteChoice === 'n' ? 'richtig' : (deleteChoice === 'y' ? 'falsch' : '') }}
									<br />
									{{ deleteChoice === 'n' ? 'Das sollte dir gut bewusst sein. Jede deiner Nachrichten wird für immer bleiben.' : '' }}
								</td>
							</tr>
						</table>

						<br />

					</p>
				</div>
				<div ng-if="selectedLevel == 3 && selectedMission == 3 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Konsens referenziert generell erstmal nur darauf, sich zu einigen.<br />
									Insbesondere auf Daten zu einigen.<br /><br />

									Wir haben hierzu den Proof-of-Work Algorithmus:
									<ul>
										<li>Transaktionen sammeln</li>
										<li>In Blöcke zusammenfassen</li>
										<li>Den Nonce finden</li>
										<li>Lösung mit dem Netzwerk teilen</li>
									</ul>
								</td>
								<td>
									Aber es gibt immer mehr Konsensalgorithmen.<br />
									Insbesondere da der Proof-of-Work sehr rechenintensiv ist.<br /><br />

									Die neue Ethereum-Blockchain nutzt einen Proof-of-Stake.<br />
									Das heisst Konsens finden besondere Nutzer, die dafür mit ihrem Vermögen
									haften.<br /><br />

									Es gibt noch sehr viele mehr.<br />
									Immer an Use Case und Situation angepasst.
								</td>
							</tr>
						</table>

						<br />

					</p>
				</div>

				<div ng-if="selectedLevel == 4 && selectedMission == 0 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Wie du gelernt hast, ist die Blocksuche die Suche nach der Lösung zur
									Challenge.<br />
									Wichtig dabei, es ist sehr schwer die Lösung zu finden, aber sehr leicht sie zu
									verifizieren.<br /><br />

									Das heisst also, dass wer als erstes diesen Nonce findet, dieser Miner den Block
									gefunden hat.<br />
									Idealerweise sind in solch öffentlichen Netzwerken, die Schwierigkeitsstufen
									dynamisch geregelt.<br />
									Das heisst, je weniger Miner, desto einfacher wird die Challenge.<br />
									Andernfalls, würden Transaktionen ewig brauchen, bis sie bestätigt werden. <br />
								</td>
								<td class="center_image">
									<div class="block_cover">
										Blockhash: {{ simulatePoW(currentBlock) }}

										<div class="block_header">
											Blocknummer: {{ currentBlock.b }} <br />
											Anzahl an Transaktionen: {{ currentBlock.l.length }} <br />
											Vorheriger Blockhash: {{ currentBlock.p }} <br /><br />
											Nonce: <input type="text" size="40" disabled ng-model="nonceInputPoW" />
										</div>

										<div class="block_body">
											<div ng-repeat="message in currentBlock.l" class="block_body_item">
												<div>
													<span class="msg_sender">{{ getNickname(message.s) }} &#x2192;
														{{ getNickname(message.r) }}
														{{ message.b ? '&#128274; ' : '' }}</span> <br />
													{{ message.m }}
												</div>
												<div style="display:right">
													<span class="msg_infos">Signierter Hash: </span> <br />
													<span class="msg_infos capped">{{ message.h }}</span>
												</div>
											</div>
										</div>
									</div>
								</td>
							</tr>
						</table>
						<br />
					</p>
				</div>

				<div ng-if="selectedLevel == 4 && selectedMission == 1 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Die unbestätigten Nachrichten (unconfirmed transactions) sind Nachrichten, die noch
									in keinem Block sind.<br />
									Sie werden also in einem Pool aufgefangen und warten bis ein Miner einen Block
									findet.<br />
									Trotzdem sind diese im ganzen Netzwerk bekannt, denn sonst würden die Miner diese
									Infos nicht bekommen.<br /><br />

									Miner suchen sich auch jene Transaktionen, bei denen sie die höchsten Gebühren
									bekommen.<br />
									Daher gilt normal, je mehr Tokens du für deine Nachricht ausgibst, umso schneller
									wird sie akzeptiert.<br /><br />

									Du kannst dir das analog zu einer Word-Datei vorstellen.<br />
									Solange du die Datei nicht speicherst, sind die Änderungen nicht bestätigt.<br />
									Mit dem Speichern (Block gefunden) werden sie endgültig gespeichert. <br />
								</td>
								<td class="center_image">
									<div class="block_body">
										<div ng-repeat="message in unspend.l" class="block_body_item">
											<div>
												<span class="msg_sender">{{ getNickname(message.s) }} &#x2192;
													{{ getNickname(message.r) }}
													{{ message.b ? '&#128274; ' : '' }}</span> <br />
												{{ message.m }}
											</div>
											<div style="display:right">
												<span class="msg_infos">Signierter Hash: </span> <br />
												<span class="msg_infos capped">{{ message.h }}</span>
											</div>
										</div>
									</div>

								</td>
							</tr>
						</table>
						<br />
					</p>
				</div>

				<div ng-if="selectedLevel == 4 && selectedMission == 2 ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Bisher haben wir immer, davon gesprochen, es sei unmöglich, Daten zu
									verändern.<br />
									Das stimmt nicht ganz. Es ist mit einem gigantischen Aufwand durchaus möglich.<br />
									Dazu musst du letztendlich wissen, was es bedeutet Daten zu
									manipulieren.<br /><br />

									Transaktionsdaten kannst du nicht manipulieren, wegen den fehlenden private
									keys.<br />
									Du kannst dich aber als Miner betätigen, und so über neue Daten entscheiden.<br />
									Wenn du also die absolute Mehrheit (>50%) der Rechenpower hat, kannst du das
									ziemlich gut sogar. <br /><br />

									Aber das ist so gut wie unmöglich.
								</td>
								<td></td>
							</tr>
						</table>
						<br />
					</p>
				</div>

				<div class="floating_confirm">
					<button class="button" id="completionBtn" ng-click="missionCompleted()">Mission
						abschliessen</button>
				</div>


			</div>
		</div>
	</div>

	<div class="fade_content">
		<div class="badge">
			<div class="badge__label">+2</div>
		</div>
	</div>

	<div class="push">
	</div>

	<!-- The Modal -->
	<div id="popupModal" class="modal">

		<!-- Modal content -->
		<div class="modal_content">
			<span class="close">&times;</span>
			<h1 class="page_title">Neue Konversation mit</h1>
			<div class="activity_feed">
				<div class="activity_item" ng-repeat="participant in getNonConvoParticipants() track by participant"
					ng-click="newConvoSelected(participant)">
					<div>
						<b>{{ participant }}</b>
					</div>
				</div>
			</div>
		</div>

	</div>

	<!-- The Welcome Modal -->
	<div id="welcomeModal" class="modal welcome_modal">

		<!-- Modal content -->
		<div class="modal_content" ng-if="welcomeContentIndex == 0 ">
			<h1 class="page_title">Hej!</h1>
			<p class="introduction_section">
				Willkommen in unserer Blockchain.<br />
				Du wirst gleich mit all deinen Schülern chatten können.<br />
				Besonders dabei ist, dass ihr das auf einer Blockchain werdet.
			</p>
			<div class="floating_confirm">
				<button class="button" ng-click="continueWelcome()">Weiter</button>
			</div>
		</div>

		<div class="modal_content" ng-if="welcomeContentIndex == 1 ">
			<h1 class="page_title">Chatten</h1>
			<p class="introduction_section">
				In einer Blockchain wirst du immer mit einem kryptischen Schlüssel eindeutig sein.<br />
				Aber das ist nicht so praktikabel.<br /><br />
				Also geb dir doch einen Nickname:<br />
				<input type="text" size="40" maxlength="50" placeholder="Nickname..." ng-model="nicknameInput" />
			</p>
			<div class="floating_confirm">
				<button class="button" ng-click="nicknameGiven(nicknameInput)" ng-if="nicknameInput !== '' ">Weiter</button>
			</div>
		</div>

		<div class="modal_content" ng-if="welcomeContentIndex == 2 ">
			<h1 class="page_title">Eintauchen</h1>
			<p class="introduction_section">
				Du wirst natürlich nicht nur chatten können.<br />
				Oben rechts hast du den Button, um die Blockchain aus allen Perspektiven zu sehen.<br /><br />
				Du darfst in Missionen kontinuerlich lernen, wie eine Blockchain funktioniert.<br />
				Da wirst du auch verstehen, warum du auf Nachrichten warten musst ;-)
			</p>
			<div class="floating_confirm">
				<button class="button" ng-click="completeWelcome()">Let's go!</button>
			</div>
		</div>

	</div>

</body>

</html>