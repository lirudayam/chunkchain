<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <title>Chunkchain - Blockchain Try Out</title>
  <link href="style.css" rel="stylesheet" />
  <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.8.2/angular.min.js"></script>
  <script>
    function log(message) {
		console.log(message);
      //document.getElementById("log").textContent += message + "\n";
    }
  </script>
  <script src="https://chr15m.github.io/bugout/bugout.min.js" type="application/javascript"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/crypto-js.min.js"></script>
  <script src="https://momentjs.com/downloads/moment.js"></script>
  
  
</head>
<body ng-app="chunkchain">
	<script>
		let fnScope = null;
		angular.module('chunkchain', [])
		  .controller('ChatController', ['$scope', function($scope) {
			$scope.levelList = {
				'Level 1: Einsteiger': [
					'Überblick',
					'Unser Netzwerk',
					'Wo sind die Daten?',
					'Sind die Daten echt?'
				],
				'Level 2: Anfänger': [
					'Was ist ein Hash?',
					'Was ist Verschlüsselung?',
					'Was schicken wir uns immer?',
					'Wo sind die Nachrichten?'
				],
				'Level 3: Fortgeschritten': [
					'Was ist ein Block?',
					'Wie sieht ein Block aus?',
					'Wie entsteht ein Block?',
					'Wie entsteht die Kette?'
				],
				'Level 4: Profi': [
					'Wie kann ich verschlüsseln?',
					'Soll ich Blöcke suchen?',
					'Kann ich löschen?',
					'Wie finden wir Konsens?'
				],
				'Level 5: Voll-Profi': [
					'Wie wird die Blocksuche geregelt?',
					'Was sind unbestätigte Nachrichten?',
					'Kann ich Daten manipulieren?'
				]
			};
			$scope.selectedLevel = 'Level 1: Einsteiger';
			$scope.selectedMission = '';
			$scope.symText = "Mein Text";
			$scope.symKey = "Schlüssel";
			$scope.symEncrypt = "";
			$scope.symDecryptKey = $scope.symKey;

			$scope.coins = 1;
			$scope.publicKey = "6c157587185fd2";
			$scope.privateKey = "6c157587185fd2";

			$scope.selectedBlock = {
				h: "6c157587185fd2", // h - hash
				p: "6c157587185fa3", // p - previous block
				t: 1614164551, // t - time
				n: 1234, // n - nonce
				b: 12, // b - block_index
				r: "abc", // r - miner
				l: [
					{
						c: 1,
						h: "U2FsdGVkX187vuFZEYVK9oiJScxLLF5xy3oXTh0CYg8BMeMfnkN+u+0joDa/VUB1P6BaZ6Y0gza7wPIOtP8yUA==",
						m: "abc",
						r: "all",
						s: "bQfr1YkzJUmDfWcYw4mVBrfqhYYBrBZGFU",
						t: 1614164098394
					},
					{
						c: 1,
						h: "U2FsdGVkX1+6pT9PvXLhnoG7asbQOA0k+z9bg93vz9jz8VQzQf9GM/m5/wXlTaUBIBp/2Fkr9RTIfHwH3opDyA==",
						m: "Hallo",
						r: "all",
						s: "bQfr1YkzJUmDfWcYw4mVBrfqhYYBrBZGFU",
						t: 1614164095076
					},
					{
						c: 1,
						h: "U2FsdGVkX19O9lgRwVgi0LzdW4tUFtPu37e4EBPe3FUlig3B036z4Ed+oelLKqtWrrSpUMXSSFiLY2e65/wfXA==",
						m: "tttggg",
						r: "all",
						s: "bQfr1YkzJUmDfWcYw4mVBrfqhYYBrBZGFU",
						t: 1614164200647
					},
					{
						c: 1,
						h: "U2FsdGVkX183BIsk6Ib0gq4bh9V2Blqx/UXSk9K02iFVhnoXdAYjMN41Q7l6q2k893j3jGr/ns2bvX+Q92QBOg==",
						m: "t2",
						r: "all",
						s: "bVNNaMSw86LwqszABuR9WNeaKzkoPKLFEY",
						t: 1614164168352
					}
				] // l - list of transactions
			};

			$scope.missionSelected = function(sSelectedItem) {
				$scope.selectedMission = sSelectedItem;
			};
			$scope.hash = function(sInput) {
				return CryptoJS.SHA1(sInput).toString();
			};
			$scope.encrypt = function(sInput, sKey) {
				const encrypt = CryptoJS.AES.encrypt(sInput, CryptoJS.enc.Base64.parse(sKey), { iv: CryptoJS.enc.Base64.parse("iv"), padding: CryptoJS.pad.NoPadding });
				console.log(encrypt);
				if ($scope.symEncrypt === "") {
					$scope.symEncrypt = encrypt.toString(CryptoJS.format.Hex);
				}
				return encrypt.toString(CryptoJS.format.Hex);
			};
			$scope.decrypt = function(sInput, sKey) {
				if (sInput !== "") {
					const encryptedHex = CryptoJS.enc.Hex.parse(sInput);
					const decrypt = CryptoJS.AES.decrypt({ciphertext: encryptedHex}, CryptoJS.enc.Base64.parse(sKey), { iv: CryptoJS.enc.Base64.parse("iv"), padding: CryptoJS.pad.NoPadding });
					//
					console.log(decrypt); //CryptoJS.enc.Utf8
					return decrypt.toString(); //TODO: fix it

				}
				return "";
			}
			$scope.timestamp = function () {
				return moment().unix();
			}
			$scope.hashTx = function () {
				const sComboundString = $scope.publicKey + "all" + $scope.messageSimulation + $scope.coins + $scope.timestamp();
				const sHashString = CryptoJS.enc.Hex.stringify(CryptoJS.SHA1(sComboundString.toString()));
				return sHashString;
			}
			$scope.hashTxSigned = function () {
				return CryptoJS.AES.encrypt($scope.hashTx(), $scope.privateKey).toString();
			}
			
			fnScope = $scope;
		  }]);

		  window.onload = () => {
			//const oAngularScope = angular.element(document.body).scope();
			console.log(fnScope);
			console.log(fnScope.activeConversations);
		  }


	  </script>
    <div class="header">
        <img src="assets/ChunkChain_Logo.svg" width="200px" />

        <div class="header_items">
            <a>zur Chat-Ansicht</a>
            <span>dein Kontostand: <b>100 Token</b></span>
        </div>
    </div>

    <div class="main_body" ng-controller="ChatController">
        <div class="background_container">
			<div class="level_container">
				<select ng-options="level as level for (level, data) in levelList" ng-model="selectedLevel"></select>
				
				<div class="mission_container">
					<div ng-repeat="mission in levelList[selectedLevel]" class="{{ mission === selectedMission ? 'selected_mission' : 'mission' }}" ng-click="missionSelected(mission)">
						{{ mission }}
					</div>
				</div>
			</div>

			<div class="info_container">
				<h1 class="page_title">{{ selectedMission }}</h1>
				<div ng-if="selectedMission == 'Unser Netzwerk' ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Unser Chat basiert auf eine verteilten System. Aber was ist ein verteiltes System?<br />
									Unten siehst du unsere klassische Client-Server-Architektur wie du sie aus Chat-Apps wie WhatsApp und Co kennst.<br />
									Normalerweise schicken wir die Nachrichten an einen Server und dieser leitet sie dann weiter.<br />
								</td>
								<td>
									Bei uns sind das anders aus. Wie du siehst, gibt es kein Server. Jeder kommuniziert direkt mit jedem.<br />
									Da wir alle gleichwertig in diesem Netzwerk sind, reden wir gar nicht mehr von Client oder Server, sondern von Peers.<br />
									Wir sind alle Peers, weswegen uns das zu einem Peer-to-Peer Netzwerk macht aka P2P.<br />
								</td>
							</tr>
							<tr>
								<td class="center_image">
									<img src="./assets/Client_Server.svg" />
								</td>
								<td class="center_image">
									<img src="./assets/P2P_Network.svg" />
								</td>
							</tr>
						</table>
						
						<br />
						
					</p>
				</div>
				<div ng-if="selectedMission == 'Wo sind die Daten?' ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Tatsächlich ist das eine gute Frage und gar nicht so einfach.<br />
									Schauen wir uns da nocheinmal die klassische Client-Server-Architektur an.<br />
									Hier werden alle Daten auf dem Server in einer zentralen Datenbank gespeichert.<br />
								</td>
								<td>
									Und hier speichern wir tatsächlich <i>alle</i> Daten auf <i>allen</i> Peer-Rechnern.<br />
									Diese Redundanz ist bewusst erzeugt, um das System stabiler zu machen.<br />
									Fällt ein Rechner aus, sind genug andere noch da. Doch das ganze System hat auch Nachteile.<br />
								</td>
							</tr>
							<tr>
								<td class="center_image">
									<img src="./assets/Client_Server_Data.svg" />
								</td>
								<td class="center_image">
									<img src="./assets/P2P_Network_Data.svg" />
								</td>
							</tr>
						</table>
						
						<br />
						
					</p>
				</div>
				<div ng-if="selectedMission == 'Sind die Daten echt?' ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Auch das ist eine sehr gute Frage.<br />
									Bei klassischen Client-Server-Architektur, sind die Daten zentral auf dem Server.<br />
									Wir vertrauen also diesem Server, dass die Daten echt sind.<br />
									Das machen wir sehr häufig. Wir vertrauen Services wie Amazon, PayPal, Instagram tagtäglich.<br />
								</td>
								<td>
									Was ist aber wenn wir keine zentrale Instanz haben, der wir vertrauen können?<br />
									Das P2P Network erzeugt bewusst Redundanz, sodass wir nicht einer einzelnen Person vertrauen müssen.<br />
									Stattdessen vertrauen wir dem gesamten System und überprüfen uns gegenseitig.<br />
									Das bedeutet aber auch, dass wir auf jede noch so kleine Information gemeinsam einigen müssen.<br />
								</td>
							</tr>
							<tr>
								<td class="center_image">
									<img src="./assets/Client_Server_Data.svg" />
								</td>
								<td class="center_image">
									<img src="./assets/P2P_Network_Data.svg" />
								</td>
							</tr>
						</table>
						
						<br />
						
					</p>
				</div>

				<div ng-if="selectedMission == 'Was ist ein Hash?' ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Ein Hash ist eine Möglichkeit eine Zeichenkette (String) zu komprimieren.<br />
									Wenn wir einen String hashen, bekommen wir immer einen neuen String einer fixen Länge raus.<br />
									Dabei ist egal, wie lang der anfängliche String ist, es kommt immer die gleiche Länge vom Hash raus.<br /><br />
									
									Hashes haben dabei drei wesentliche Eigenschaften:
									<ul>
										<li>Aus einem Hash ist es unmöglich den orginalen String zurückzubekommen</li>
										<li>Es ist unmöglich aus einem String-Hash-Paar einen weiteren String mit dem gleichen Hash zu finden</li>
										<li>Es ist unmöglich zwei Strings zu finden, die den gleichen Hash haben</li>
									</ul>
								</td>
								<td>
									Der Vorteil ist, Hashes sind leicht zu speichern und man kann so Daten überprüfen.<br />
									Änderst du nur einen Buchstaben im orginalen String, sieht der Hash komplett anders aus.<br /><br />

									Willst du es ausprobieren, z.B. SHA1 (Secure Hash Algorithm):<br />
									<input type="text" size="60" placeholder="Gib deinen Text ein..." ng-model="hashInput" /> <br /><br />
									Hash: <b>{{ hash(hashInput) }}</b>
								</td>
							</tr>
						</table>
						
						<br />
						
					</p>
				</div>
				<div ng-if="selectedMission == 'Was ist Verschlüsselung?' ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Die <b>symmetrische</b> Verschlüsselung nutzt das Prinzip, dass du eine Nachricht mit dem gleichen Schlüssel verschlüsseln und entschlüsseln kannst.<br />
									Das ist ähnlich wie bei einem Haustürschloss. Du kannst deinen Schlüssel nutzen, um die Tür aufzumachen und abzuschliessen.<br /><br />
								</td>
								<td>
									Bei einer <b>asymmetrischen</b> Verschlüsselung hast du einen Schlüssel zum Verschlüsseln (<b>private key</b>) und einen zum Entschlüsseln (<b>public key</b>).<br />
									Um ein solches Schlüssel-Paar zu erzeugen, generierst du einen private key und leitest einen public key davon ab.<br />
									Man kann von einem public key nie den dazugehörigen private key erraten. <br />
									Du kannst natürlich auch private und public key andersherum einsetzen.
								</td>
							</tr>
							<tr>
								<td>
									Ein Beispiel: <br />
									<div class="form">
										Nachricht: <input type="text" size="50" ng-model="symText" /> <br /><br />
										Dein Schlüssel: <input type="text" size="50" ng-model="symKey" /> <br /><br />
										Verschlüsselte Nachricht: <b>{{ encrypt(symText, symKey) }}</b>
									</div>
									<br /><hr /><br />
									Zum Entschlüsseln:
									<div class="form">
										Verschlüsselte Nachricht: <input type="text" size="50" ng-model="symEncrypt" /> <br /><br />
										Dein Schlüssel: <input type="text" size="50" ng-model="symDecryptKey" /> <br /><br />
										Entschlüsselte Nachricht: <b>{{ decrypt(symEncrypt, symDecryptKey) }}</b>
									</div>
								</td>
							</tr>
						</table>
						
						<br />
						
					</p>
				</div>
				<div ng-if="selectedMission == 'Was schicken wir uns immer?' ">
					<p class="introduction_section">
						Deine Nachricht wird als eine Transaktion geschickt. Dabei sieht die Struktur wie folgt aus:

						<ul class="flow">
							<li><b>Orginale Transaction</b> <br /><br />
								{<br />
									<span class="attribute">sender:</span> "{{ publicKey }}",<br />
									<span class="attribute">recipient:</span> "all",<br />
									<span class="attribute">message:</span> "<input type="text" size="10" ng-model="messageSimulation" />",<br />
									<span class="attribute">coins:</span> {{ coins }}<br />
								}<br />
							</li>
							<li><b>Zeitstempel dazu</b> <br /><br />
								{<br />
									<span class="attribute">sender:</span> "{{ publicKey }}",<br />
									<span class="attribute">recipient:</span> "all",<br />
									<span class="attribute">message:</span> "{{ messageSimulation }}",<br />
									<span class="attribute">coins:</span> {{ coins }}<br />
									<span class="attribute">time:</span> <span class="highlighted">{{ timestamp() }}</span><br />
								}<br />
							</li>
							<li><b>Hash hinzufügen</b> <br /><br />
								{<br />
									<span class="attribute">sender:</span> "{{ publicKey }}",<br />
									<span class="attribute">recipient:</span> "all",<br />
									<span class="attribute">message:</span> "{{ messageSimulation }}",<br />
									<span class="attribute">coins:</span> {{ coins }}<br />
									<span class="attribute">time:</span> {{ timestamp() }}<br />
									<span class="attribute">hash:</span> <div class="cut-text">{{ hashTx() }}</div><br />
								}</li>
							<li><b>Hash signieren mit private key</b> <br /><br />
								{<br />
									<span class="attribute">sender:</span> "{{ publicKey }}",<br />
									<span class="attribute">recipient:</span> "all",<br />
									<span class="attribute">message:</span> "{{ messageSimulation }}",<br />
									<span class="attribute">coins:</span> {{ coins }}<br />
									<span class="attribute">time:</span> {{ timestamp() }}<br />
									<span class="attribute">hash:</span> <div class="cut-text">{{ hashTxSigned() }}</div><br />
								}</li>
								<li><b>ins P2P-Netzwerk</b></li>
						  </ul>
					</p>
				</div>
				<div ng-if="selectedMission == 'Wo sind die Nachrichten?' ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Dazu müssen wir uns nur unser P2P-Netzwerk anschauen.<br />
									Wir haben hier extra Redundanz, sodass das System robuster wird.<br />
									Also hat auch jeder eine vollständige Kopie der Daten.<br />
									Das kann natürlich ziemlich schnell, ziemlich gross werden, weswegen es auch off-chain Lösungen gibt.<br /><br />
									In unserem Fall speichern wir jede Transaktion bei jedem Peer. <br />
									Das heisst, du kannst auch immer sehen, wer wem geschrieben hat.
								</td>
								<td class="center_image">
									<img src="./assets/P2P_Network_Data.svg" />
								</td>
							</tr>
						</table>
						
						<br />
						
					</p>
				</div>

				<div ng-if="selectedMission == 'Was ist ein Block?' ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Bisher hast du einiges gelernt zu unserem P2P-Netzwerk und zu Hashes und Verschlüsselung.<br />
									Nachrichten sind immer Transaktionen und enthalten viele Informationen und den signierten Hash.<br /><br />

									Wie du ebenfalls zuvor gesehen hast, müssen wir uns in einem P2P-Netzwerk auf jede Information einigen.<br />
									Das würde sehr viel Abstimmung bedeuten.<br />
									Stattdessen sammeln wir neue Daten einfach in einem Pool (<b>unconfirmed transactions</b>).<br />
									Nun kann sich jemand der Aufgabe stellen, einige dieser Transaktionen zu sammeln und zur Abstimmung bringen.<br /><br />

									Der Vorgang einen Block zur Abstimmung zu bringen, benötigt viel Aufwand.<br />
									Das siehst du gleich.
								</td>
								<td class="center_image">
									<img src="./assets/P2P_Network_Data.svg" />
								</td>
							</tr>
						</table>
						
						<br />
						
					</p>
				</div>
				<div ng-if="selectedMission == 'Wie sieht ein Block aus?' ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Ein Block ist eine Ansammlung an Transaktionen. <br />
									Sobald ein Block bestätigt ist, hat jeder Teilnehmer im P2P-Netzwerk die Info, dass dieser Block wahre Daten enthält. <br /><br />

									Ein Block besteht dabei aus einem <b>block body</b> und <b>block header</b>.<br />
									Der Body enthält nur die Liste der Transaktionen. <br /><br />

									Bisher haben wir gelernt, dass wir mit einem Hash überprüfen können, ob ein String verändert wurde.<br />
									Wenn wir diesen Hash signieren, können wir sogar sicherstellen, dass niemand den Hash ändern kann.<br />
									Aber wie können wir feststellen, dass niemand einen Block ändern kann? <br /><br />

									Dazu müssen wir von allen Transaktionshashes, einen grossen Hash (<b>block hash</b>) bauen.<br />
									Damit können wir super leicht feststellen, ob jetzt jemand auch nur irgendetwas verändert hat.<br />
									Diesen speichern wir im block header ab.<br /><br />

									Wie wir jetzt aber sicherstellen können, dass niemand diesen block hash verändert, siehst du in der nächsten Mission.<br />
									Du kannst dir aber zuerst mal einen x-beliebigen Block anschauen.
								</td>
								<td class="center_image">
									<!--
										Place here real block
									-->
									<div class="block_cover">
										Blockhash: {{ selectedBlock.h }}

										<div class="block_header">
											Blocknummer: {{ selectedBlock.r }} <br />
											Anzahl an Transaktionen: {{ selectedBlock.l.length }} <br /><br />
											gefunden von: {{ selectedBlock.r }} <br />
											gefunden um: {{ selectedBlock.t }} <br />
											Vorheriger Blockhash: {{ selectedBlock.p }}
										</div>

										<div class="block_body">
											<div ng-repeat="message in selectedBlock.l" class="block_body_item">
												<div>
													<span class="msg_sender">{{ message.s }} &#x2192; {{ message.r }}</span> <br />
													{{ message.m }}
												</div>
												<div style="display:right">
													<span class="msg_infos">{{ message.c }} Coins</span> <br />
													<span class="msg_infos">{{ message.t }}</span>
												</div>
											</div>
										</div>
									</div>
								</td>
							</tr>
						</table>
						
						<br />
						
					</p>
				</div>
				<div ng-if="selectedMission == 'Wie entsteht ein Block?' ">
					<p class="introduction_section">
						<table>
							<tr>
								<td>
									Jede Transaktion (Nachricht) wird direkt im gesamten Netzwerk geteilt. <br />
									Jeder Teilnehmer kann hierbei prüfen, ob die Transaktion gültig ist. <br />
									Wenn dies der Fall sein sollte, landen die Transaktionen in einem Pool (unconfirmed transaction pool). <br /><br />

									Jetzt muss sich jemand der Aufgabe stellen, einen Block zu finden.<br />
									Dabei sucht die Person die Lösung (Nonce) einer kryptographischen Challenge. <br /><br />

									Jede Transaktion hat einen Hash. Nun kann die Hashes von Transaktionen aus einem Pool wiederrum zusammenhashen.<br />
									Dabei entsteht der sogenannte Merkle-Root (Hash der Hashes).<br /><br />

									Mit dem Merkle-Root zusammen werden einige Informationen aus dem <b>block header</b> weiter gehasht.<br />
									Darunter sind vorallem der Blockhash des vorherigen Blocks und Zeitstempel.<br /><br />

									Die kryptographische Challenge liegt darin eine einen Hash zu finden, der mit Nullen beginn.<br />
									Wie du vorhin gesehen hast, verändert ein Buchstabe einen Hash komplett. <br />
									Jetzt muss jemand eine x-beliebige Zeichenfolge zu den bestehenden Daten zu finden, sodass der Hash mit x Nullen beginnt. <br />
									Je mehr Nullen am Anfang gefordert sind, desto schwieriger wird es. <br /><br />

									Einfaches Beispiel: <br />
									Wenn ein Blockhash mit einer Null beginnen soll, braucht man ca. 16 Versuche. <br />
									Wenn ein Blockhash mit drei Nullen beginnen soll, braucht man ca. 4096 Versuche. <br />
									Bei sechs Nullen, sind es schon über 16 Millionen. <br />
									Das Bitcoin-Netzwerk verlangt aktuell 19 Nullen am Anfang!
								</td>
								<td class="center_image">
									<!--
										Place here real block
									-->
									<div class="block_cover">
										Blockhash: {{ calcBlockHash }}

										<div class="block_header">
											Blocknummer: {{ currentBlock.b }} <br />
											Anzahl an Transaktionen: {{ currentBlock.l.length }} <br /><br />
											
											Vorheriger Blockhash: {{ selectedBlock.p }} <br />
											Nonce: <input type="text" size="40" placeholder="Probier es aus..." ng-model="nonceInput" />
										</div>

										<div class="block_body">
											<div ng-repeat="message in currentBlock.l" class="block_body_item">
												<div>
													<span class="msg_sender">{{ message.s }} &#x2192; {{ message.r }}</span> <br />
													{{ message.m }}
												</div>
												<div style="display:right">
													<span class="msg_infos">Hash: </span> <br />
													<span class="msg_infos">{{ message.h }}</span>
												</div>
											</div>
										</div>
									</div>
								</td>
							</tr>
						</table>
						
						<br />
						
					</p>
				</div>
			</div>
		</div>

    </div>

</body>
</html>
